data <- read.csv("oefendata.csv", header = FALSE)
data <- read.csv(file.choose(), header = FALSE)
key <- as.matrix(data[1,])
input.answers <- as.matrix(data[3:nrow(data),2:ncol(data)])
n.answer.op <- rep(3, ncol(input.answers))
set.seed(1)
category <- sample(1:5, ncol(input.answers), replace = TRUE)
results <- Score(key, input.answers, n.answer.op, item.names = NULL, category)
key
library(psych)
library(psy)
library(plyr)
Score <- function(key, input.answers, n.answer.op, item.names = NULL, category) {
# Computes standard psychometric properties of an exam
#
# Arguments:
#   key: matrix of 0's and 1's. Key[i,j] implies wether answer option i to item j is right (1) or wrong (0). If a row (item) consists of
#        only 0s, the item is interpreted as graded manually.
#   input.answers: Ungraded matrix of answers. input.answers[i,j] is the answer of student (i) to item (j).
#   number.answersoptions: Vector with number of answer options per item, should be equal to number of collumns of input.answers
#   category: vector which item belongs to which category
#
# Returns:
#   list with: Cronbach's alpha, maximum number of answer options, frequency and percentage correct per item, corrected item total correlation,
#   frequence and percentage of each answer options per item, and corrected item total correlation per answer option.
# Create key matrix
old.key <- key # save original key
k <- matrix(0, nrow = max(n.answer.op), ncol = length(n.answer.op))
colnames(k) <- colnames(input.answers)
for(i in 1:ncol(k))
{
k[key[i],i] = 1
}
key <- k #
# Create Correct/Incorrect Matrix
if(is.null(item.names)){
item.names <- paste("Item ",1:ncol(input.answers),sep = "")
}
colnames(input.answers) <- item.names
input.correct <- input.answers
# count amount of items per category
cat.items <- as.matrix(count(category))
colnames(cat.items) <- c("category", "n.items")
sub.cat <- which(cat.items[,2] > 2, arr.ind = TRUE) # save which subcategories to process
err <- data.frame("category" = which(cat.items[,2] <= 2, arr.ind = TRUE)) # save for which categories to produce a warning
# Fill in Correct/Incorrect Matrix
for (j in 1: ncol(input.answers)) {
if (any(key[, j] != 0)) {  # If no key is supplied for a question, item is seen as manually graded and input.answers is used directly
input.correct[, j] <- as.numeric(input.answers[, j] %in% which(key[, j] == 1))
}
}
results <- Analyse(key, input.answers, input.correct, n.answer.op)
#If multiple categories are present, repeat the analysis for every category
if(any(category > 1)){
results = list(results)
for(c in 1:length(sub.cat)){
sel <- which(category == sub.cat[c])
results <- c(results, list(Analyse(matrix(key[, sel], ,length(sel)), matrix(input.answers[, sel], ,length(sel), dimnames = list(NULL, item.names[sel])),
matrix(input.correct[, sel], , length(sel), dimnames = list(NULL, item.names[sel])), n.answer.op[sel])) )
}
}
results[[1]][[(length(results[[1]]) + 1)]] <- err
names(results[[1]])[length(results[[1]])] <- "error"
results[[1]][[(length(results[[1]]) + 1)]] <- sub.cat
names(results[[1]])[length(results[[1]])] <- "subcats"
return(results)
}
Analyse <- function(key, input.answers, input.correct, n.answer.op) {
n.stud <- nrow(input.answers)
n.item <- ncol(input.answers)
# Creating Frequency Matrix and Item rest Cor for total scores
item.sum <- colSums(input.correct)
item.perc <- round(item.sum / n.stud * 100, digits = 1)
# Calculate percentage per answer option. Only if any non 0s are present in key
if (any(key != 0)) {
freq.answer.op <- matrix(, max(n.answer.op) + 1, n.item)
for (j in 1 : n.item){
if (any(key[, j] != 0)){
freq.answer.op[,j] <- table(factor(input.answers[, j], levels = 0:max(n.answer.op)))
}
}
colnames(freq.answer.op) <- colnames(input.correct)
rownames(freq.answer.op) <- c("Times_Answer_Missing", paste("Times", LETTERS[1:max(n.answer.op)], "answered", sep = "_"))
# Percentage answered per answer option per questions
perc.answer.op <- round(freq.answer.op / n.stud * 100, digits = 1)
} else{
freq.answer.op <- 0
perc.answer.op <- 0
}
# Calculate corrected item tot correlation per item
if(n.stud > 1 & n.item > 2){
item.tot.cor <- numeric()
suppressWarnings(  # If no one or everyone answered an item correctly, R returns NA and a warning
for (j in 1 : n.item) {
item.tot.cor <- c(item.tot.cor, cor(input.correct[, j], rowSums(input.correct[, -j]) ))
}
)
item.tot.cor[is.na(item.tot.cor)] <- 0 # Correct for when all students answered correctly or incorrectly
item.tot.cor <- round(item.tot.cor, digits = 3)
names(item.tot.cor) <- colnames(input.correct)
# Create frequency matrix and correct item total cor for each answer option
# only if any non 0's are present in key
if (any(key != 0)) {
# Calculate corrected item total correlation per answer option
answer.op.tot.cor <- matrix(, max(n.answer.op) + 1, n.item)
suppressWarnings(
for (i in 0:max(n.answer.op)) {
for (j in 1:n.item) {
if (any(key[, j] != 0)) {
answer.op.tot.cor[i + 1, j] <- round(cor(as.numeric(input.answers[, j] == i), rowSums(input.correct[, -j])),
digits = 3)
if (is.na(answer.op.tot.cor[i + 1, j])) {
answer.op.tot.cor[i + 1, j] <- 0
}
} else {
answer.op.tot.cor[i + 1, j] <- NA
}
}
}
)
rownames(answer.op.tot.cor) <- c("Times_Answer_Missing", paste("Times", LETTERS[1:max(n.answer.op)], "answered", sep = "_"))
colnames(answer.op.tot.cor) <- colnames(input.correct)
}
if (all(key == 0)) {
answer.op.tot.cor <- 0
}
# Computes Cronbach's Alpha
cronbach <- round(cronbach(input.correct)$alpha, digits = 3)
} else {
cronbach <- 0
item.tot.cor <- 0
answer.op.tot.cor <- 0
}
list(n.stud = n.stud, n.item = n.item, cronbach = cronbach, item.sum = item.sum, key = key,
n.answer.op = n.answer.op, input.correct = input.correct, #max(n.answer.op),
item.perc = item.perc, item.tot.cor = item.tot.cor, freq.answer.op = freq.answer.op,
perc.answer.op = perc.answer.op, answer.op.tot.cor = answer.op.tot.cor)
}
results <- Score(key, input.answers, n.answer.op, item.names = NULL, category)
save(results, file = "oefendata.RData")
library(ggplot2)
library(pander)
library(plyr)
retrieve <- function(results, n = NULL, sub.cat){
if(sub.cat){
list2env(results[[n]], envir  = globalenv())
} else {
list2env(results, envir  = globalenv())
}
}
if(is.list(results[[1]])) sub.cat = TRUE else sub.cat = FALSE
retrieve(results, n = 1, sub.cat) # Get objects in list to global environment
CreateItemList <- function(input.correct, n.answer.op, freq.answer.op = NULL, perc.answer.op = NULL, answer.op.tot.cor = NULL, item.sum = NULL, item.perc = NULL, item.tot.cor = NULL){
# Creates a list with frequency, percentage correct, and IRC for every item.
#
# Args:
#  input.correct: Matrix with [i,j]  the score of student i on item j
#  n.answer.op: Vector with number of answer options per question
#  freq.answer.op: Matrix with [i,j] the frequency of answer option i of item j
#  perc.answer.op: Matrix with [i,j] the percentage of answer option i of item j
#  answer.op.tot.cor: Matrix with [i,j] the item total correlation for answer option i of item j
#  item.sum: Vector with total number correct per item
#  item.perc: Vector with percentage correct per item
#  item.tot.cor: Vector with item rest correlation per item
#
# Returns:
#  A list with frequency, percentage and IRC for total and each answer options (if answer options exist).
item.names <- colnames(input.correct)
item.list <- list() # Creates list to put item output in
colnames1 <- c(" ", "frequency", "percentage", "IRC")
colnames2 <- c("answer.option", "frequency", "percentage", "IRC", "Correct")
for (i in 1:n.item) {
if (n.answer.op[i] > 0) {
Correct <- c(ifelse(key[1:n.answer.op[i], i] == 1, "Correct", "Incorrect"), "Incorrect")
# Frequency is also stored at this point, but not used.
# in case someone wants to alter the script to display the frequency instead of the percentage
item.list[[i]] <- data.frame(c(LETTERS[1:n.answer.op[i]], "Missing"),
c(freq.answer.op[c(2:(n.answer.op[i] + 1), 1), i]),
c(perc.answer.op[c(2:(n.answer.op[i] + 1), 1), i]),
c(answer.op.tot.cor[c(2:(n.answer.op[i] + 1), 1), i]),
Correct,
row.names = NULL)
colnames(item.list[[i]]) <- colnames2
} else {
item.list[[i]] <- data.frame("Correct", item.sum[i],
item.perc[i],
item.tot.cor[i])
colnames(item.list[[i]]) <- colnames1
}
}
#Create item names
names(item.list) <- item.names
item.list
}
item.list <- CreateItemList(input.correct = input.correct, n.answer.op = n.answer.op, freq.answer.op = freq.answer.op, perc.answer.op = perc.answer.op, answer.op.tot.cor = answer.op.tot.cor, item.sum = item.sum, item.perc = item.perc, item.tot.cor = item.tot.cor)
# Use the function defined above
# Create a dataframe with only the correct statistics. This is used in the general item plots
CreateDf <- function(input.correct, item.sum, item.tot.cor, item.perc){
correct.df <- data.frame(item = factor(colnames(input.correct), colnames(input.correct)), item.sum, item.tot.cor, item.perc ,
perc.col = ifelse(item.perc < 40, 0, ifelse(item.perc > 70, 1, 1/75 * item.perc - 7/30)),
# From 0 to 40 perc correct the bar is coloured red. From 40 till 70 colours go from .3 till .7 (orange till green-ish. From 70 till 100, bar is coloured green.
irc.col = ifelse(item.tot.cor < 0, 0, ifelse(item.tot.cor > .1, 1, 4 * item.tot.cor + 3/10))
# Below 0 IRC, an item is colour red. Between 0 and .1 an item is coloured orange. Higher than .1 an item is coloured green.
)
t <- regexpr("\\d+", correct.df$item) ## Extract only numbers from item names
correct.df$item <- factor(regmatches(correct.df$item, t), regmatches(correct.df$item, t))
correct.df
}
correct.df <- CreateDf(input.correct = input.correct, item.sum = item.sum, item.tot.cor = item.tot.cor, item.perc = item.perc)
# Create extra variables for the colours in the bar plots
PercCol <- function(item.perc, Correct){
# Calculate colours for the percentage answer options.
#Args:
# item.perc: Percentage answered per answer options
# correct:   Vector of "Correct" and "Incorrect" of same length of item.perc
#
#Returns:
# Value between 0 and 1 with 0 corresponding to red and 1 to green in the plots.
# For the correct answers: lower than 40 returns 0, higher than 70 returns 1, and in between returns a scale from .3 till .7.
# For the incorrect answers: difference between lowest correct answer option and incorrect answer options are calculated.
# If the difference is bigger than 0, it returns 0. If difference is smaller than -10, it returns 1. In between returns a scale from .3 till .7.
perc.col <- vector()
perc.col[Correct == "Correct"] <- ifelse(item.perc[Correct == "Correct"] < 40, 0, ifelse(item.perc[Correct == "Correct"] > 70, 1, 3/200 * item.perc - 3/10))
dif <- item.perc[Correct == "Incorrect"] - min(item.perc[Correct == "Correct"])
perc.col[Correct == "Incorrect"] <- ifelse(dif >= 0, 0, ifelse(dif < -10, 1, -1/25 * dif + 3/10))
return(perc.col)
}
IrcCol <- function(IRC, Correct){
# Calculate colours for the percentage answer options.
#Args:
# IRC:     IRC per answer options
# correct: Vector of "Correct" and "Incorrect" of same length of IRC
#
#Returns:
# Value between 0 and 1 with 0 corresponding to red and 1 to green in the plots.
# For the correct answers: lower than 0 returns 0, higher than .1 returns 1, and in between returns a scale from .3 till .7.
# For the incorrect answers: difference between incorrect answer options and lowest correct answer option are calculated.
# If the difference is bigger than 0, it returns 0. If difference is smaller than -.05, it returns 1. In between returns a scale from .3 till .7.
IRC.col <- vector()
IRC.col[Correct == "Correct"] <- ifelse(IRC[Correct == "Correct"] < 0, 0, ifelse(IRC[Correct == "Correct"] > .1, 1, 3 * IRC + 3/10))
dif <- IRC[Correct == "Incorrect"] - min(IRC[Correct == "Correct"])
IRC.col[Correct == "Incorrect"] <- ifelse(dif >= 0, 0, ifelse(dif < -.05, 1, -8 * dif + 3/10))
return(IRC.col)
}
i = 3
with(item.list[[i]], PercCol(percentage, Correct))
percentage = item.list[[i]]$percentage
Correct = item.list[[i]]$Correct
IRC.col <- vector()
IRC.col[Correct == "Correct"] <- ifelse(IRC[Correct == "Correct"] < 0, 0, ifelse(IRC[Correct == "Correct"] > .1, 1, 3 * IRC + 3/10))
perc.col[Correct == "Correct"] <- ifelse(item.perc[Correct == "Correct"] < 40, 0, ifelse(item.perc[Correct == "Correct"] > 70, 1, 3/200 * item.perc - 3/10))
perc.col <- vector()
perc.col[Correct == "Correct"] <- ifelse(item.perc[Correct == "Correct"] < 40, 0, ifelse(item.perc[Correct == "Correct"] > 70, 1, 3/200 * item.perc - 3/10))
perc.col
dif <- item.perc[Correct == "Incorrect"] - min(item.perc[Correct == "Correct"])
perc.col[Correct == "Incorrect"] <- ifelse(dif >= 0, 0, ifelse(dif < -10, 1, -1/25 * dif + 3/10))
perc.col
perc.col <- vector()
perc.col[Correct == "Correct"] <- ifelse(item.perc[Correct == "Correct"] < 40, 0, ifelse(item.perc[Correct == "Correct"] > 70, 1, 3/200 * item.perc - 3/10))
dif <- item.perc[Correct == "Incorrect"] - min(item.perc[Correct == "Correct"])
perc.col[Correct == "Incorrect"] <- ifelse(dif >= 0, 0, ifelse(dif < -10, 1, -1/25 * dif + 3/10))
perc.col
with(item.list[[i]], PercCol(percentage, Correct))
percentage
Correct
item.list[[i]]
perc.col <- vector()
?vector
str(perc.col)
perc.col <- vector("numeric", length = length(Correct))
perc.col[Correct == "Correct"] <- ifelse(item.perc[Correct == "Correct"] < 40, 0, ifelse(item.perc[Correct == "Correct"] > 70, 1, 3/200 * item.perc - 3/10))
ifelse(item.perc[Correct == "Correct"] < 40, 0, ifelse(item.perc[Correct == "Correct"] > 70, 1, 3/200 * item.perc - 3/10))
Correct
item.perc
perc.col <- vector("numeric", length = length(Correct))
perc.col[Correct == "Correct"] <- ifelse(percentage[Correct == "Correct"] < 40, 0, ifelse(percentage[Correct == "Correct"] > 70, 1, 3/200 * percentage - 3/10))
ifelse(percentage[Correct == "Correct"] < 40, 0, ifelse(percentage[Correct == "Correct"] > 70, 1, 3/200 * percentage - 3/10))
percentage[Correct == "Correct"] < 40
ifelse(percentage[Correct == "Correct"] > 70
percentage[Correct == "Correct"] > 70
3/200 * percentage - 3/10
perc.col[Correct == "Correct"] <- ifelse(percentage[Correct == "Correct"] < 40, 0, ifelse(percentage[Correct == "Correct"] > 70, 1, 1/75 * percentage - 7/30))
perc.col
1/75 * percentage - 7/30
percentage
1/75 * 40
1/75 * 40 - 7/30
1/75 * 50 - 7/30
Correct
percentage[Correct == "Correct"]
perc.col[Correct == "Correct"] <- ifelse(percentage[Correct == "Correct"] < 40, 0, ifelse(percentage[Correct == "Correct"] > 70, 1, 1/75 * percentage[Correct == "Correct"] - 7/30))
perc.col
n = 3
sub.cat
retrieve(results, n = 1, sub.cat) # Get objects in list to global environment
CreateItemList <- function(input.correct, n.answer.op, freq.answer.op = NULL, perc.answer.op = NULL, answer.op.tot.cor = NULL, item.sum = NULL, item.perc = NULL, item.tot.cor = NULL){
# Creates a list with frequency, percentage correct, and IRC for every item.
#
# Args:
#  input.correct: Matrix with [i,j]  the score of student i on item j
#  n.answer.op: Vector with number of answer options per question
#  freq.answer.op: Matrix with [i,j] the frequency of answer option i of item j
#  perc.answer.op: Matrix with [i,j] the percentage of answer option i of item j
#  answer.op.tot.cor: Matrix with [i,j] the item total correlation for answer option i of item j
#  item.sum: Vector with total number correct per item
#  item.perc: Vector with percentage correct per item
#  item.tot.cor: Vector with item rest correlation per item
#
# Returns:
#  A list with frequency, percentage and IRC for total and each answer options (if answer options exist).
item.names <- colnames(input.correct)
item.list <- list() # Creates list to put item output in
colnames1 <- c(" ", "frequency", "percentage", "IRC")
colnames2 <- c("answer.option", "frequency", "percentage", "IRC", "Correct")
for (i in 1:n.item) {
if (n.answer.op[i] > 0) {
Correct <- c(ifelse(key[1:n.answer.op[i], i] == 1, "Correct", "Incorrect"), "Incorrect")
# Frequency is also stored at this point, but not used.
# in case someone wants to alter the script to display the frequency instead of the percentage
item.list[[i]] <- data.frame(c(LETTERS[1:n.answer.op[i]], "Missing"),
c(freq.answer.op[c(2:(n.answer.op[i] + 1), 1), i]),
c(perc.answer.op[c(2:(n.answer.op[i] + 1), 1), i]),
c(answer.op.tot.cor[c(2:(n.answer.op[i] + 1), 1), i]),
Correct,
row.names = NULL)
colnames(item.list[[i]]) <- colnames2
} else {
item.list[[i]] <- data.frame("Correct", item.sum[i],
item.perc[i],
item.tot.cor[i])
colnames(item.list[[i]]) <- colnames1
}
}
#Create item names
names(item.list) <- item.names
item.list
}
item.list <- CreateItemList(input.correct = input.correct, n.answer.op = n.answer.op, freq.answer.op = freq.answer.op, perc.answer.op = perc.answer.op, answer.op.tot.cor = answer.op.tot.cor, item.sum = item.sum, item.perc = item.perc, item.tot.cor = item.tot.cor)
# Use the function defined above
correct.df <- CreateDf(input.correct = input.correct, item.sum = item.sum, item.tot.cor = item.tot.cor, item.perc = item.perc)
i = 2
with(item.list[[i]], IrcCol(IRC, Correct))
item.list[i]
n
retrieve(results, n = 1, sub.cat) # Get objects in list to global environment
item.list <- CreateItemList(input.correct = input.correct, n.answer.op = n.answer.op, freq.answer.op = freq.answer.op, perc.answer.op = perc.answer.op, answer.op.tot.cor = answer.op.tot.cor, item.sum = item.sum, item.perc = item.perc, item.tot.cor = item.tot.cor)
# Use the function defined above
item.list[2]
retrieve(results, n = 3, sub.cat) # Get objects in list to global environment
item.list <- CreateItemList(input.correct = input.correct, n.answer.op = n.answer.op, freq.answer.op = freq.answer.op, perc.answer.op = perc.answer.op, answer.op.tot.cor = answer.op.tot.cor, item.sum = item.sum, item.perc = item.perc, item.tot.cor = item.tot.cor)
# Use the function defined above
correct.df <- CreateDf(input.correct = input.correct, item.sum = item.sum, item.tot.cor = item.tot.cor, item.perc = item.perc)
IrcCol(IRC, Correct)
with(item.list[[i]], IrcCol(IRC, Correct))
i
item.list[[2]]
